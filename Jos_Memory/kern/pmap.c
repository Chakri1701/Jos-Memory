#include <inc/x86.h>
#include <inc/mmu.h>
#include <inc/error.h>
#include <inc/string.h>
#include <inc/assert.h>

#include <kern/pmap.h>
#include <kern/kclock.h>
// These variables are set by i386_detect_memory()
 size_t npages;           // Amount of physical memory (in pages)
 static size_t npages_basemem;    // Amount of base memory (in pages)
//
// // These variables are set in mem_init()
 pde_t *kern_pgdir;       // Kernel's initial page directory
 struct PageInfo *pages;      // Physical page state array
 static struct PageInfo *page_free_list;  // Free list of physical pages
// --------------------------------------------------------------
// // Detect machine's physical memory setup.
// // --------------------------------------------------------------
static int
nvram_read(int r)
{
        return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}

static void
i386_detect_memory(void)
{
        size_t basemem, extmem, ext16mem, totalmem;


            // Use CMOS calls to measure available base & extended memory.
            //  // (CMOS calls return results in kilobytes.)
            basemem = nvram_read(NVRAM_BASELO);
            extmem = nvram_read(NVRAM_EXTLO);
            ext16mem = nvram_read(NVRAM_EXT16LO) * 64;
            // Calculate the number of physical pages available in both base
            // // // and extended memory.
            if (ext16mem)
                totalmem = 16 * 1024 + ext16mem;
            else if (extmem)
                totalmem = 1 * 1024 + extmem;
            else
                totalmem = basemem;

            npages = totalmem / (PGSIZE / 1024);
            npages_basemem = basemem / (PGSIZE / 1024);

            cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
                    totalmem, basemem, totalmem - basemem);
}

// --------------------------------------------------------------
// // Set up memory mappings above UTOP.
// // --------------------------------------------------------------
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
static void check_page_free_list(bool only_low_memory);
static void check_page_alloc(void);
static void check_kern_pgdir(void);
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
static void check_page(void);
static void check_page_installed_pgdir(void);

// This simple physical memory allocator is used only while JOS is setting
// // up its virtual memory system.  page_alloc() is the real allocator.
// //
// // If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// // bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
// //
// // If n==0, returns the address of the next free page without allocating
// // anything.
// //
// // If we're out of memory, boot_alloc should panic.
// // This function may ONLY be used during initialization,
// // before the page_free_list list has been set up.
  static void *
  boot_alloc(uint32_t n)
{
        static char *nextfree;  // virtual address of next byte of free memory
            char *result;

 // Initialize nextfree if this is the first time.
 //     // 'end' is a magic symbol automatically generated by the linker,
 //         // which points to the end of the kernel's bss segment:
 //             // the first virtual address that the linker did *not* assign
 //                 // to any kernel code or global variables
  if (!nextfree) {
            extern char end[];
                    nextfree = ROUNDUP((char *) end, PGSIZE);
 }
 // Allocate a chunk large enough to hold 'n' bytes, then update
 //     // nextfree.  Make sure nextfree is kept aligned
 //         // to a multiple of PGSIZE.
 //
 //                // LAB 2: Your code here.
    result = nextfree;
    if (n > 0) {
        nextfree = ROUNDUP(nextfree + n, PGSIZE);
        if (((uint32_t) nextfree - KERNBASE) > (npages * PGSIZE)) {
            panic("boot_alloc: out of memory. Requested %uK, available %uK.\n", (uint32_t) nextfree / 1024, npages * PGSIZE / 1024);
        }
    }
    return result;
}

// Set up a two-level page table:
// //    kern_pgdir is its linear (virtual) address of the root
// //
// // This function only sets up the kernel part of the address space
// // (ie. addresses >= UTOP).  The user part of the address space
// // will be set up later.
// //
// // From UTOP to ULIM, the user is allowed to read but not write.
// // Above ULIM the user cannot read or write.
void
mem_init(void)
{
        uint32_t cr0;
            size_t n;

                // Find out how much memory the machine has (npages & npages_basemem).
              i386_detect_memory();
                //
                //      // Remove this line when you're ready to test this function.
     //         panic("mem_init: This function is not finished\n");

              //////////////////////////////////////////////////////////////////////
              //    // create initial page directory.
              kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
              memset(kern_pgdir, 0, PGSIZE);

              //////////////////////////////////////////////////////////////////////
              //    // Recursively insert PD in itself as a page table, to form
              //        // a virtual page table at virtual address UVPT.
              //            // (For now, you don't have understand the greater purpose of the
              //                // following line.)
              //
              //                    // Permissions: kernel R, user R
              kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

              //////////////////////////////////////////////////////////////////////
              //    // Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
              //        // The kernel uses this array to keep track of physical pages: for
              //            // each physical page, there is a corresponding struct PageInfo in this
              //                // array.  'npages' is the number of physical pages in memory.  Use memset
              //                    // to initialize all fields of each struct PageInfo to 0.
              //                        // Your code goes here:
     pages = (struct PageInfo *)boot_alloc(npages * sizeof(struct PageInfo));
     memset(pages, 0, npages * sizeof(struct PageInfo));
              //
              //                            //////////////////////////////////////////////////////////////////////
              //                                // Now that we've allocated the initial kernel data structures, we set
              //                                    // up the list of free physical pages. Once we've done so, all further
              //                                        // memory management will go through the page_* functions. In
              //                                            // particular, we can now map memory using boot_map_region
              //                                                // or page_insert
              page_init();

              check_page_free_list(1);
              check_page_alloc();
              check_page();

              // Map 'pages' read-only by the user at linear address UPAGES
                   boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);

              // Map kernel stack from [KSTACKTOP-PTSIZE, KSTACKTOP)
                   boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);

               //Map all of physical memory at KERNBASE.
                   boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W | PTE_P);


              check_kern_pgdir();

              lcr3(PADDR(kern_pgdir));

              check_page_free_list(0);

              cr0 = rcr0();
              cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
              cr0 &= ~(CR0_TS|CR0_EM);
              lcr0(cr0);

              check_page_installed_pgdir();
}

 void
 page_init(void)
{
    size_t i;
                 for (i = 1; i < npages_basemem; i++) {
                             pages[i].pp_ref = 0;
                                     pages[i].pp_link = page_free_list;
                                             page_free_list = &pages[i];
                                                 }
                     for (i = IOPHYSMEM / PGSIZE; i < EXTPHYSMEM / PGSIZE; i++) {
                                 pages[i].pp_ref = 1;
                                     }
                         for (i = EXTPHYSMEM / PGSIZE; i < npages; i++) {
                                     if (i < PADDR(boot_alloc(0)) / PGSIZE) {
                                                     pages[i].pp_ref = 1;
                                                             } else {
                                                                             pages[i].pp_ref = 0;
                                                                                         pages[i].pp_link = page_free_list;
                                                                                                     page_free_list = &pages[i];
                                                                                                             }
                                         }
        }

struct PageInfo *
page_alloc(int alloc_flags)
{
  struct PageInfo *result;

      if (page_free_list == NULL) {
                  return NULL;
                      }

          result = page_free_list;
              page_free_list = page_free_list->pp_link;
                  result->pp_link = NULL;
                      if (alloc_flags & ALLOC_ZERO) {
                                  memset(page2kva(result), 0, PGSIZE);
                                      }
                          return result;

 }

void
page_free(struct PageInfo *pp)
{  if (pp->pp_ref != 0 || pp->pp_link != NULL) {
            panic("page_free: cannot free page");
                }
    pp->pp_link = page_free_list;
        page_free_list = pp;


}

void
page_decref(struct PageInfo* pp)
{
        if (--pp->pp_ref == 0)
            page_free(pp);
}

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
 pde_t *pde = &pgdir[PDX(va)];
     uint32_t *pt_addr;

     if (!(*pde & PTE_P)) {
         if (!create) {
             return NULL;
         }

         struct PageInfo *pp;
         if ((pp = page_alloc(ALLOC_ZERO)) == NULL) {  // allocate and clear the page
             return NULL;
         }
         pp->pp_ref++;
         *pde = page2pa(pp) | PTE_P | PTE_W | PTE_U;
                                                         }
             pt_addr = KADDR(PTE_ADDR(*pde));
                 return (pte_t *)(pt_addr + PTX(va));
}

static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
 size_t i;
     for (i = 0; i < size / PGSIZE; i++) {
                 pte_t *pte;

                         if ((pte = pgdir_walk(pgdir, (void *)va, 1)) == NULL) {
                                         panic("boot_map_region: allocation failure");
                                                 }
                                 *pte = pa | perm | PTE_P;
                                         va += PGSIZE;
                                                 pa += PGSIZE;
                                                     }
}

 int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
     pte_t *pte;

         if ((pte = pgdir_walk(pgdir, va, 1)) == NULL) {
                     return -E_NO_MEM;
                         }
         pp->pp_ref++;
         if (*pte & PTE_P) {
                         page_remove(pgdir, va);
                             }
                     *pte = page2pa(pp) | perm | PTE_P;
                         return 0;
        // Fill this function in
}

 struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
     pte_t *pte;

         if ((pte = pgdir_walk(pgdir, va, 0)) == NULL || (*pte & PTE_P) == 0) {
                     return NULL;
                         }
             if (pte_store) {
                         *pte_store = pte;
                             }
                 return pa2page(PTE_ADDR(*pte));
}

 void
 page_remove(pde_t *pgdir, void *va)
{
 struct PageInfo *pp;
     pte_t *pte;

         if ((pp = page_lookup(pgdir, va, &pte)) == NULL) {
                     return;
                         }
             page_decref(pp);
             *pte = 0;
             tlb_invalidate(pgdir, va);
}

 void
 tlb_invalidate(pde_t *pgdir, void *va)
{
    invlpg(va);
}

 static void
 check_page_free_list(bool only_low_memory)
{
        struct PageInfo *pp;
        unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
        int nfree_basemem = 0, nfree_extmem = 0;
        char *first_free_page;

        if (!page_free_list)
            panic("'page_free_list' is a null pointer!");

        if (only_low_memory) {

            struct PageInfo *pp1, *pp2;
            struct PageInfo **tp[2] = { &pp1, &pp2 };
            for (pp = page_free_list; pp; pp = pp->pp_link) {
                int pagetype = PDX(page2pa(pp)) >= pdx_limit;
                *tp[pagetype] = pp;
                tp[pagetype] = &pp->pp_link;
            }
            *tp[1] = 0;
            *tp[0] = pp2;
            page_free_list = pp1;
        }

        for (pp = page_free_list; pp; pp = pp->pp_link)
            if (PDX(page2pa(pp)) < pdx_limit)
                memset(page2kva(pp), 0x97, 128);

        first_free_page = (char *) boot_alloc(0);
        for (pp = page_free_list; pp; pp = pp->pp_link) {

            assert(pp >= pages);
            assert(pp < pages + npages);
            assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);

            assert(page2pa(pp) != 0);
            assert(page2pa(pp) != IOPHYSMEM);
            assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
            assert(page2pa(pp) != EXTPHYSMEM);
            assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);

            if (page2pa(pp) < EXTPHYSMEM)
                        ++nfree_basemem;
            else
                    ++nfree_extmem;
        }
        assert(nfree_basemem > 0);
        assert(nfree_extmem > 0);

        cprintf("check_page_free_list() succeeded!\n");
}

 static void
 check_page_alloc(void)
{
        struct PageInfo *pp, *pp0, *pp1, *pp2;
        int nfree;
        struct PageInfo *fl;
        char *c;
        int i;
        if (!pages)
            panic("'pages' is a null pointer!");

        for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
                ++nfree;

        pp0 = pp1 = pp2 = 0;
        assert((pp0 = page_alloc(0)));
        assert((pp1 = page_alloc(0)));
        assert((pp2 = page_alloc(0)));

        assert(pp0);
        assert(pp1 && pp1 != pp0);
        assert(pp2 && pp2 != pp1 && pp2 != pp0);
        assert(page2pa(pp0) < npages*PGSIZE);
        assert(page2pa(pp1) < npages*PGSIZE);
        assert(page2pa(pp2) < npages*PGSIZE);

        fl = page_free_list;
        page_free_list = 0;

        assert(!page_alloc(0));

        page_free(pp0);
        page_free(pp1);
        page_free(pp2);
        pp0 = pp1 = pp2 = 0;
        assert((pp0 = page_alloc(0)));
        assert((pp1 = page_alloc(0)));
        assert((pp2 = page_alloc(0)));
        assert(pp0);
        assert(pp1 && pp1 != pp0);
        assert(pp2 && pp2 != pp1 && pp2 != pp0);
        assert(!page_alloc(0));

        memset(page2kva(pp0), 1, PGSIZE);
        page_free(pp0);
        assert((pp = page_alloc(ALLOC_ZERO)));
        assert(pp && pp0 == pp);
        c = page2kva(pp);
        for (i = 0; i < PGSIZE; i++)
                assert(c[i] == 0);

        page_free_list = fl;

        page_free(pp0);
        page_free(pp1);
        page_free(pp2);

        for (pp = page_free_list; pp; pp = pp->pp_link)
                --nfree;
        assert(nfree == 0);

        cprintf("check_page_alloc() succeeded!\n");
}

 static void
 check_kern_pgdir(void)
{
        uint32_t i, n;
        pde_t *pgdir;

        pgdir = kern_pgdir;

        n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
        for (i = 0; i < n; i += PGSIZE)
                assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);

        for (i = 0; i < npages * PGSIZE; i += PGSIZE)
                assert(check_va2pa(pgdir, KERNBASE + i) == i);

        for (i = 0; i < KSTKSIZE; i += PGSIZE)
                assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
        assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);


        for (i = 0; i < NPDENTRIES; i++) {
            switch (i) {
            case PDX(UVPT):
            case PDX(KSTACKTOP-1):
            case PDX(UPAGES):
                assert(pgdir[i] & PTE_P);
                break;
            default:
                if (i >= PDX(KERNBASE)) {
                    assert(pgdir[i] & PTE_P);
                    assert(pgdir[i] & PTE_W);
                } else
                    assert(pgdir[i] == 0);
                break;
            }
        }
        cprintf("check_kern_pgdir() succeeded!\n");
}

 static physaddr_t
 check_va2pa(pde_t *pgdir, uintptr_t va)
{
        pte_t *p;

        pgdir = &pgdir[PDX(va)];
        if (!(*pgdir & PTE_P))
            return ~0;
        p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
        if (!(p[PTX(va)] & PTE_P))
            return ~0;
        return PTE_ADDR(p[PTX(va)]);
}

 static void
 check_page(void)
{
        struct PageInfo *pp, *pp0, *pp1, *pp2;
        struct PageInfo *fl;
        pte_t *ptep, *ptep1;
        void *va;
        int i;
        extern pde_t entry_pgdir[];

        pp0 = pp1 = pp2 = 0;
        assert((pp0 = page_alloc(0)));
        assert((pp1 = page_alloc(0)));
        assert((pp2 = page_alloc(0)));

        assert(pp0);
        assert(pp1 && pp1 != pp0);
        assert(pp2 && pp2 != pp1 && pp2 != pp0);

        fl = page_free_list;
        page_free_list = 0;

        assert(!page_alloc(0));

        assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);

        assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);

        page_free(pp0);
        assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
        assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
        assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
        assert(pp1->pp_ref == 1);
        assert(pp0->pp_ref == 1);

        assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
        assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
        assert(pp2->pp_ref == 1);

        assert(!page_alloc(0));

        assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
        assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
        assert(pp2->pp_ref == 1);


        assert(!page_alloc(0));

        ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
        assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));


        assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
        assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
        assert(pp2->pp_ref == 1);
        assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
        assert(kern_pgdir[0] & PTE_U);


        assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
        assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
        assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

        assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);


        assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
        assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

        assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
        assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));

        assert(pp1->pp_ref == 2);
        assert(pp2->pp_ref == 0);


        assert((pp = page_alloc(0)) && pp == pp2);


        page_remove(kern_pgdir, 0x0);
        assert(check_va2pa(kern_pgdir, 0x0) == ~0);
        assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
        assert(pp1->pp_ref == 1);
        assert(pp2->pp_ref == 0);

        assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
        assert(pp1->pp_ref);
        assert(pp1->pp_link == NULL);

        page_remove(kern_pgdir, (void*) PGSIZE);
        assert(check_va2pa(kern_pgdir, 0x0) == ~0);
        assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
        assert(pp1->pp_ref == 0);
        assert(pp2->pp_ref == 0);


        assert((pp = page_alloc(0)) && pp == pp1);


        assert(!page_alloc(0));

        assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
        kern_pgdir[0] = 0;
        assert(pp0->pp_ref == 1);
        pp0->pp_ref = 0;


        page_free(pp0);
        va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
        ptep = pgdir_walk(kern_pgdir, va, 1);
        ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
        assert(ptep == ptep1 + PTX(va));
        kern_pgdir[PDX(va)] = 0;
        pp0->pp_ref = 0;


        memset(page2kva(pp0), 0xFF, PGSIZE);
        page_free(pp0);
        pgdir_walk(kern_pgdir, 0x0, 1);
        ptep = (pte_t *) page2kva(pp0);
        for(i=0; i<NPTENTRIES; i++)
                assert((ptep[i] & PTE_P) == 0);
        kern_pgdir[0] = 0;
        pp0->pp_ref = 0;


        page_free_list = fl;


        page_free(pp0);
        page_free(pp1);
        page_free(pp2);

        cprintf("check_page() succeeded!\n");
}

 static void
 check_page_installed_pgdir(void)
{
        struct PageInfo *pp, *pp0, *pp1, *pp2;
        struct PageInfo *fl;
        pte_t *ptep, *ptep1;
        uintptr_t va;
        int i;

        pp1 = pp2 = 0;
        assert((pp0 = page_alloc(0)));
        assert((pp1 = page_alloc(0)));
        assert((pp2 = page_alloc(0)));
        page_free(pp0);
        memset(page2kva(pp1), 1, PGSIZE);
        memset(page2kva(pp2), 2, PGSIZE);
        page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
        assert(pp1->pp_ref == 1);
        assert(*(uint32_t *)PGSIZE == 0x01010101U);
        page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
        assert(*(uint32_t *)PGSIZE == 0x02020202U);
        assert(pp2->pp_ref == 1);
        assert(pp1->pp_ref == 0);
        *(uint32_t *)PGSIZE = 0x03030303U;
        assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
        page_remove(kern_pgdir, (void*) PGSIZE);
        assert(pp2->pp_ref == 0);
                                                                                       assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
        kern_pgdir[0] = 0;
        assert(pp0->pp_ref == 1);
        pp0->pp_ref = 0;

        page_free(pp0);

        cprintf("check_page_installed_pgdir() succeeded!\n");
}
